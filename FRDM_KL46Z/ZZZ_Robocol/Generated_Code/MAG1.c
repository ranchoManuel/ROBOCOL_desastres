/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : MAG1.c
**     CDE edition : Standard
**     Project     : ZZZ_Robocol
**     Processor   : MKL46Z256VLL4
**     Component   : MAG3110
**     Version     : Component 01.010, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2015-03-25, 16:07, # CodeGen: 32
**     Abstract    :
**         Implements a driver for the MAG3110 Magnetometer from Freescale
**     Settings    :
**          Component Name                                 : MAG1
**          Slave Address                                  : 0E
**          I2C Bus                                        : GI2C1
**          Shell                                          : Disabled
**     Contents    :
**         Enable              - byte MAG1_Enable(void);
**         Disable             - byte MAG1_Disable(void);
**         GetXYZ8             - uint8_t MAG1_GetXYZ8(signed char *xyz);
**         GetX                - byte MAG1_GetX(int16_t *value);
**         GetY                - byte MAG1_GetY(int16_t *value);
**         GetZ                - byte MAG1_GetZ(int16_t *value);
**         SetFastReadMode     - byte MAG1_SetFastReadMode(bool on);
**         GetFastReadMode     - byte MAG1_GetFastReadMode(bool *isOn);
**         GetTemperature      - byte MAG1_GetTemperature(signed char *temperature);
**         GetSysMode          - byte MAG1_GetSysMode(byte *mode);
**         SetSysMode          - byte MAG1_SetSysMode(byte mode);
**         WriteReg            - byte MAG1_WriteReg(byte reg, byte val);
**         ReadReg             - byte MAG1_ReadReg(byte addr, byte *val);
**         MagneticSensorReset - byte MAG1_MagneticSensorReset(void);
**         Init                - uint8_t MAG1_Init(void);
**         Deinit              - uint8_t MAG1_Deinit(void);
**
**     License : Open Source (LGPL)
**     Copyright : (c) Copyright Erich Styger, 2013, all rights reserved.
**     http://www.mcuoneclipse.com
**     This an open source software in the form of a Processor Expert Embedded Component.
**     This is a free software and is opened for education, research and commercial developments under license policy of following terms:
**     * This is a free software and there is NO WARRANTY.
**     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
**     * Redistributions of source code must retain the above copyright notice.
** ###################################################################*/
/*!
** @file MAG1.c
** @version 01.00
** @brief
**         Implements a driver for the MAG3110 Magnetometer from Freescale
*/         
/*!
**  @addtogroup MAG1_module MAG1 module documentation
**  @{
*/         

/* MODULE MAG1. */

#include "MAG1.h"

#define MAG1_CPU_IS_LITTLE_ENDIAN 1 /* Cpu is little endian */

#define MAG1_DIE_TEMP_OFFSET 24 /* offset to temperature reading as value on device is not calibrated */
/*
** ===================================================================
**     Method      :  MAG1_GetXYZ8 (component MAG3110)
**     Description :
**         Returns in an array the x, y and z sensor values as 8bit
**         values. Note that for this method the FAST_READ flag *shall*
**         be set.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * xyz             - Pointer to an array of three signed 8bit
**                           values which are used to return the
**                           accelerometer values.
**     Returns     :
**         ---             - Error code, ERR_OK for no error.
** ===================================================================
*/
uint8_t MAG1_GetXYZ8(signed char *xyz)
{
  /* NOTE: this function assumes that FAST_READ *is* set, as it reads 3 bytes */
  static const uint8_t addr = MAG1_OUT_X_MSB;

  return GI2C1_ReadAddress(MAG1_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), (uint8_t*)xyz, 3);
}


/*
** ===================================================================
**     Method      :  MAG1_Deinit (component MAG3110)
**     Description :
**         Counterpart to Init() method.
**     Parameters  : None
**     Returns     :
**         ---             - Error code, ERR_OK if everything is ok.
** ===================================================================
*/
uint8_t MAG1_Deinit(void)
{
  return ERR_OK; /* nothing to do */
}

/*
** ===================================================================
**     Method      :  MAG1_Init (component MAG3110)
**     Description :
**         Initializes the device driver
**     Parameters  : None
**     Returns     :
**         ---             - Error code, ERR_OK if everything is ok.
** ===================================================================
*/
uint8_t MAG1_Init(void)
{
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_GetX (component MAG3110)
**     Description :
**         Returns the X magnetometer value.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * value           - Pointer to where to store the value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetX(int16_t *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    int16_t be;
  } val;
  static const uint8_t addr = MAG1_OUT_X_MSB;

  if(GI2C1_ReadAddress(MAG1_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!=ERR_OK) {
    return ERR_FAILED; /* failure */
  }
#if MAG1_CPU_IS_LITTLE_ENDIAN
  *value = (int16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_GetY (component MAG3110)
**     Description :
**         Returns the Y magnetometer value.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * value           - Pointer to where to store the value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetY(int16_t *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    int16_t be;
  } val;
  static const uint8_t addr = MAG1_OUT_Y_MSB;

  if (GI2C1_ReadAddress(MAG1_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!=ERR_OK) {
    return ERR_FAILED; /* failure */
  }
#if MAG1_CPU_IS_LITTLE_ENDIAN
  *value = (int16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_GetZ (component MAG3110)
**     Description :
**         Returns the Z magnetometer value.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * value           - Pointer to where to store the value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetZ(int16_t *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    int16_t be;
  } val;
  static const uint8_t addr = MAG1_OUT_Z_MSB;

  if (GI2C1_ReadAddress(MAG1_I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!=ERR_OK) {
    return ERR_FAILED; /* failure */
  }
#if MAG1_CPU_IS_LITTLE_ENDIAN
  *value = (int16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_SetFastReadMode (component MAG3110)
**     Description :
**         Turns the FR (Fast Read Mode) bit in CTRL_REG_1 on or off
**     Parameters  :
**         NAME            - DESCRIPTION
**         on              - if to turn the FR mode on or off
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_SetFastReadMode(bool on)
{
  uint8_t val;

  if (GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  if (on) {
    val |= MAG1_CTRL_REG_1_FR_BIT_MASK; /* enable F_READ: Fast read mode, data format limited to single byte (auto increment counter will skip LSB) */
  } else {
    val &= ~MAG1_CTRL_REG_1_FR_BIT_MASK; /* disable F_READ: Fast read mode, data format limited to single byte (auto increment counter will skip LSB) */
  }
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, val);
}

/*
** ===================================================================
**     Method      :  MAG1_GetFastReadMode (component MAG3110)
**     Description :
**         Returns the FR (Fast Read Mode) status in the CTRL_REG_1
**         register
**     Parameters  :
**         NAME            - DESCRIPTION
**       * isOn            - Pointer to where to store the status of
**                           the FR bit
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetFastReadMode(bool *isOn)
{
  uint8_t val;

  if(GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *isOn = (bool)(val&MAG1_CTRL_REG_1_FR_BIT_MASK);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_Enable (component MAG3110)
**     Description :
**         Enables the device with setting the ACTIVE bit in the CTRL
**         register 1
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_Enable(void)
{
  uint8_t val, res;

  res = GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val);
  if (res!=ERR_OK) {
    return res;
  }
  val |= MAG1_CTRL_REG_1_AC_BIT_MASK; /* enable device */
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, val);
}

/*
** ===================================================================
**     Method      :  MAG1_Disable (component MAG3110)
**     Description :
**         Disables the device with clearing the ACTIVE bit in the CTRL
**         register 1
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_Disable(void)
{
  uint8_t val, res;

  res = GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, &val);
  if (res!=ERR_OK) {
    return res;
  }
  val &= ~MAG1_CTRL_REG_1_AC_BIT_MASK; /* disable device */
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_1, val);
}

/*
** ===================================================================
**     Method      :  MAG1_GetTemperature (component MAG3110)
**     Description :
**         Returns the temperature of the die as signed 8bit values in
**         degree Celsius
**     Parameters  :
**         NAME            - DESCRIPTION
**       * temperature     - Pointer to variable where
**                           to store the temperature
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetTemperature(signed char *temperature)
{
  int8_t temp;

  if (GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_DIE_TEMP, (uint8_t*)&temp) != ERR_OK) {
    return ERR_FAILED;
  }
  *temperature = (int8_t)(temp+MAG1_DIE_TEMP_OFFSET);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_GetSysMode (component MAG3110)
**     Description :
**         Returns the SYSMOD (0x08) status
**     Parameters  :
**         NAME            - DESCRIPTION
**       * mode            - Pointer to where to store the value.
**                           Returns 0x00 (STANDBY), 0x01 (ACTIVE, raw
**                           data) or 0x02 (ACTIVE, non-RAW data)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_GetSysMode(byte *mode)
{
  return GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_SYSMOD, mode);
}

/*
** ===================================================================
**     Method      :  MAG1_SetSysMode (component MAG3110)
**     Description :
**         Sets the SYSMOD (0x08) status register
**     Parameters  :
**         NAME            - DESCRIPTION
**         mode            - Set the system mode. 0x00
**                           (SYSMOD_STANDBY_BIT_MASK), 0x01
**                           (SYSMOD_ACTIVE_RAW_BIT_MASK) or 0x02
**                           (SYSMOD_ACTIVE_BIT_MASK)
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_SetSysMode(byte mode)
{
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_SYSMOD, mode);
}

/*
** ===================================================================
**     Method      :  MAG1_Read16bitBEValue (component MAG3110)
**
**     Description :
**         Reads a 16bit value to the device. Value is read in Big Endian 
**         and returned in the proper format depending of LE/BE of 
**         microcontroller.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
byte MAG1_Read16bitBEValue(byte addr, word *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    uint16_t be;
  } val;
  uint8_t res;

  res = GI2C1_ReadAddress(MAG1_I2C_ADDR, &addr, sizeof(addr), &val.buf[0], sizeof(val.buf));
  if(res!=ERR_OK) {
    return res; /* failure */
  }
#if MAG1_CPU_IS_LITTLE_ENDIAN
  *value = (uint16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  MAG1_Write16bitBEValue (component MAG3110)
**
**     Description :
**         Writes a 16bit value to the device. Value is written in Big 
**         Endian.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
byte MAG1_Write16bitBEValue(byte addr, word value)
{
  union {
    uint8_t buf[2]; /* value on device is in big endian */
    uint16_t be;
  } val;

#if MAG1_CPU_IS_LITTLE_ENDIAN
  val.buf[0] = (uint8_t)(value);
  val.buf[1] = (uint8_t)(value>>8);
#else
  val.be = val; /* already in BE */
#endif
  return GI2C1_WriteAddress(MAG1_I2C_ADDR, &addr, sizeof(addr), &val.buf[0], sizeof(val.buf));
}

/*
** ===================================================================
**     Method      :  MAG1_WriteReg (component MAG3110)
**     Description :
**         Writes to a device register address
**     Parameters  :
**         NAME            - DESCRIPTION
**         reg             - register address
**         val             - Value to write
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_WriteReg(byte reg, byte val)
{
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_SYSMOD, val);
}

/*
** ===================================================================
**     Method      :  MAG1_ReadReg (component MAG3110)
**     Description :
**         Reads from a device register address
**     Parameters  :
**         NAME            - DESCRIPTION
**         addr            - Device register address
**       * val             - Pointer to where to store the value
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_ReadReg(byte addr, byte *val)
{
  return GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, addr, val);
}

/*
** ===================================================================
**     Method      :  MAG1_MagneticSensorReset (component MAG3110)
**     Description :
**         Initiates a magnetic sensor reset cycle that will restore
**         correct operation after exposure to an excessive magnetic
**         field which exceeds the Full Scale Range but is less than
**         the Maximum Applied Magnetic Field.
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte MAG1_MagneticSensorReset(void)
{
  uint8_t val;

  if (GI2C1_ReadByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_2, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  val |= MAG1_CTRL_REG_2_MAG_RST_BIT_MASK; /* set one shot reset bit */
  return GI2C1_WriteByteAddress8(MAG1_I2C_ADDR, MAG1_CTRL_REG_2, val);
}

/* END MAG1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.08]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
